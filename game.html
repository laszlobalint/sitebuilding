<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta content="utf-8" http-equiv="encoding" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Game</title>
  </head>
  <body>
    <canvas id="game-canvas" width="800" height="600"></canvas>
    <script>
      const PADDLE_WIDTH = 100;
      const PADDLE_THICKNESS = 10;
      const PADDLE_DIST_FROM_EDGE = 60;
      const BRICK_W = 100;
      const BRICK_H = 50;
      const BRICK_COUNT = 8;
      var brickGrid = new Array(BRICK_COUNT);
      var paddleX = 400;
      var ballX = 75;
      var ballY = 75;
      var ballSpeedX = 5;
      var ballSpeedY = 7;
      var mouseX = 0;
      var mouseY = 0;
      var canvas, canvasContext;

      function updateMousePosition(evt) {
        var rect = canvas.getBoundingClientRect();
        var root = document.documentElement;

        mouseX = evt.clientX - rect.left - root.scrollLeft;
        mouseY = evt.clientY - rect.top - root.scrollTop;

        paddleX = mouseX - PADDLE_WIDTH / 2;
      }

      function brickReset() {
        for (let i = 0; i < BRICK_COUNT; i++) Math.random() < 0.5 ? (brickGrid[i] = true) : (brickGrid[i] = false);
      }

      window.onload = function () {
        canvas = document.getElementById('game-canvas');
        canvasContext = canvas.getContext('2d');

        var framesPerSecond = 30;
        setInterval(updateAll, 1000 / framesPerSecond);

        canvas.addEventListener('mousemove', updateMousePosition);

        brickReset();
      };

      function updateAll() {
        moveAll();
        drawAll();
      }

      function resetBall() {
        ballX = canvas.width / 2;
        ballY = canvas.height / 2;
      }

      function moveAll() {
        ballX += ballSpeedX;
        ballY += ballSpeedY;
        if (ballX > canvas.width || ballX < 0) ballSpeedX *= -1;
        if (ballY > canvas.height || ballY < 0) ballSpeedY *= -1;
        if (ballY > canvas.height) resetBall();

        var paddleTopY = canvas.height - PADDLE_DIST_FROM_EDGE;
        var paddleBottomY = paddleTopY + PADDLE_THICKNESS;
        var paddleLeftX = paddleX;
        var paddleRightX = paddleLeftX + PADDLE_WIDTH;

        if (ballY > paddleTopY && ballSpeedY < paddleBottomY && ballX > paddleLeftX && ballX < paddleRightX) {
          ballSpeedY *= -1;
          var centerOfPaddleX = paddleX + PADDLE_WIDTH / 2;
          var ballDistFromPaddleCenterX = ballX - centerOfPaddleX;
          ballSpeedX = ballDistFromPaddleCenterX * 0.35;
        }
      }

      function drawAll() {
        // Clear screen
        colorRect(0, 0, canvas.width, canvas.height, 'black');
        // Draw ball
        colorCircle(ballX, ballY, 10, 'white');
        // Draw paddle
        colorRect(paddleX, canvas.height - PADDLE_DIST_FROM_EDGE, PADDLE_WIDTH, PADDLE_THICKNESS, 'white');
        // Write text by mouse
        colorText(`${mouseX}, ${mouseY}`, mouseX, mouseY, 'yellow');
        // Draw bricks
        drawBricks();
      }

      function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
      }

      function colorCircle(centerX, centerY, radius, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.beginPath();
        canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
        canvasContext.fill();
      }

      function colorText(showWords, textX, textY, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.fillText(showWords, textX, textY);
      }

      function drawBricks() {
        brickGrid.forEach((v, i) => {
          if (v) colorRect(BRICK_W * i, 0, BRICK_W - 2, BRICK_H, 'blue');
        });
      }
    </script>
  </body>
</html>
